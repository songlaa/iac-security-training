<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iac security Training</title><link>/</link><description>Recent content on iac security Training</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Resources</title><link>/docs/03/1-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/03/1-resources/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/basics/resources cd $LAB_ROOT/basics/resources Step 3.1.1: Create main.tf We will start with a simple example by creating a resource of type random_integer. This resources generates a random number in the configured range.
Create a new file named main.tf in your working directory and paste the following:
resource &amp;#34;random_integer&amp;#34; &amp;#34;number&amp;#34; { min = 1000 max = 9999 } Explanation The resource block defines one (or multiple) infrastructure objects which are managed by Terraform.</description></item><item><title>Variables</title><link>/docs/03/2-variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/03/2-variables/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/basics/variables cd $LAB_ROOT/basics/variables Step 3.2.1: Create variables.tf and main.tf Create a new file named variables.tf in your working directory and add the following content:
variable &amp;#34;random_min_value&amp;#34; { type = number default = 1000 description = &amp;#34;min value of the random number&amp;#34; } Create a new file named main.tf in your working directory and add the following content:
resource &amp;#34;random_integer&amp;#34; &amp;#34;number&amp;#34; { min = var.</description></item><item><title>Outputs</title><link>/docs/03/3-outputs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/03/3-outputs/</guid><description>Preparation Finish the Variables exercise and navigate to the directory:
cd $LAB_ROOT/basics/variables Step 3.3.1: Create outputs.tf Create a new file named outputs.tf in your working directory and add the following content:
output &amp;#34;number&amp;#34; { value = random_integer.number.result description = &amp;#34;random value created by terraform&amp;#34; } Step 3.3.2: Apply the configuration Run the command
terraform apply and you should see output similar to this:
Plan: 0 to add, 0 to change, 0 to destroy.</description></item><item><title>Data Sources</title><link>/docs/03/4-data-sources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/03/4-data-sources/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/basics/data_sources cd $LAB_ROOT/basics/data_sources Step 3.4.1: Create resources Create a new file named main.tf in your working directory and paste the following:
resource &amp;#34;random_integer&amp;#34; &amp;#34;number&amp;#34; { min = 1000 max = 9999 } resource &amp;#34;local_file&amp;#34; &amp;#34;random&amp;#34; { content = random_integer.number.result filename = &amp;#34;random.txt&amp;#34; } Step 3.4.2: Apply the configuration Run the commands
terraform init terraform apply You will see on the console the resource random_integer.</description></item><item><title>Types / Functions</title><link>/docs/03/5-types-and-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/03/5-types-and-functions/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/basics/types cd $LAB_ROOT/basics/types Documentation for the built-in functions can be found at: https://www.terraform.io/docs/language/functions/index.html Step 3.5.1: String interpolation Create a new file named strings.tf and add the following content:
locals { counter = 5 } output &amp;#34;counter&amp;#34; { value = &amp;#34;Counter is ${local.counter}&amp;#34; } Run init and apply:
terraform init terraform apply Step 3.5.2: Working with lists Create a new file named lists.</description></item><item><title>Versions</title><link>/docs/04/1-versions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/04/1-versions/</guid><description>Preparation Finish the Data Sources exercise and copy the directory:
mkdir -p $LAB_ROOT/intermediate/ cp -r $LAB_ROOT/basics/data_sources $LAB_ROOT/intermediate/versions cd $LAB_ROOT/intermediate/versions Step 4.1.1: Create versions.tf Create a new file named versions.tf and add the following content:
terraform { required_version = &amp;#34;&amp;gt;= 1.9.4&amp;#34; required_providers { random = { source = &amp;#34;hashicorp/random&amp;#34; version = &amp;#34;= 3.1.0&amp;#34; } local = { source = &amp;#34;hashicorp/local&amp;#34; version = &amp;#34;= 2.1.0&amp;#34; } } } Explanation With multiple engineers working on the same infrastructure code base, it is inevitable to have different versions of the Terraform CLI installed.</description></item><item><title>Count / Loops</title><link>/docs/04/2-count-loops/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/04/2-count-loops/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/intermediate/count_loops cd $LAB_ROOT/intermediate/count_loops Step 4.2.1: Conditional resource By adding the identifier count to a resource, you can either make the resource conditional or create multiple instances.
Create a new file named elvis.tf in your working directory and paste the following:
locals { create_password = false } resource &amp;#34;random_password&amp;#34; &amp;#34;optional_password&amp;#34; { count = local.create_password ? 1 : 0 length = 16 } output &amp;#34;optional_password&amp;#34; { sensitive = true value = local.</description></item><item><title>Backend State</title><link>/docs/04/3-backend-state/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/04/3-backend-state/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/intermediate/backend_state cd $LAB_ROOT/intermediate/backend_state Step 4.3.1: Define a backend Create a new file named main.tf and add the following content:
terraform { backend &amp;#34;local&amp;#34; { path = &amp;#34;foobar.tfstate&amp;#34; } } resource &amp;#34;random_password&amp;#34; &amp;#34;super_secret&amp;#34; { length = 16 } Run the commands
terraform init terraform apply After the apply run:
ls -al Now you should see a local file named foobar.tfstate containing the Terraform state.</description></item><item><title>Config Files</title><link>/docs/04/4-config-files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/04/4-config-files/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/intermediate/multi_env cd $LAB_ROOT/intermediate/multi_env Step 4.4.1: Define variable and output Create a new file named variables.tf and add the following content:
variable &amp;#34;environment&amp;#34; {} Create a new file named outputs.tf and add the following content:
output &amp;#34;current_env&amp;#34; { value = var.environment } Create a new file named main.tf and add the following content:
terraform { backend &amp;#34;local&amp;#34; {} } Explanation The backend of type local is declared but missing the path argument; this is a so-called &amp;ldquo;partial configuration&amp;rdquo;.</description></item><item><title>Modules</title><link>/docs/05/1-modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/1-modules/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/advanced/modules cd $LAB_ROOT/advanced/modules Step 5.1.1: Define the module A local module resides in its own directory, lets create one be running:
mkdir random_file Create a new file named random_file/variables.tf and add the following content:
variable &amp;#34;extension&amp;#34; {} variable &amp;#34;size&amp;#34; {} Create a new file named random_file/main.tf and add the following content:
resource &amp;#34;random_pet&amp;#34; &amp;#34;filename&amp;#34; { } resource &amp;#34;random_password&amp;#34; &amp;#34;content&amp;#34; { length = var.</description></item><item><title>Meta-Arguments</title><link>/docs/05/2-meta-arguments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/2-meta-arguments/</guid><description>Preparation Create a new directory for this exercise:
mkdir -p $LAB_ROOT/advanced/meta_arguments cd $LAB_ROOT/advanced/meta_arguments Step 5.2.1: Missing dependency Sometimes Terraform can not imply the dependency between resources explicitly. For such cases, a dependency is added to one or multiple resources or data sources. Consider the following snippets.
Create a new file named main.tf and add the following content:
resource &amp;#34;local_file&amp;#34; &amp;#34;foobar_txt&amp;#34; { content = &amp;#34;4thelulz&amp;#34; filename = &amp;#34;foobar.txt&amp;#34; } data &amp;#34;local_file&amp;#34; &amp;#34;reference&amp;#34; { filename = &amp;#34;foobar.</description></item><item><title>Various</title><link>/docs/05/3-various/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/3-various/</guid><description>Preparation Create a new directory for this exercise:
mkdir $LAB_ROOT/advanced/various cd $LAB_ROOT/advanced/various Step 5.3.1: Variable structure Terraform variables support nested complex types like nested maps and sets. The type keyword of the variable block allows the definition of type constraints to enforce the correctness of the input (or default) value. See https://developer.hashicorp.com/terraform/language/expressions/type-constraints for the specification.
Create a new file named variables.tf and add the following content:
variable &amp;#34;clouds&amp;#34; { default = { aws = { company = &amp;#34;Amazon&amp;#34; founder = &amp;#34;Jeff Bezos&amp;#34; cloud_rank = 1 } azure = { company = &amp;#34;Microsoft&amp;#34; founder = &amp;#34;Bill Gates&amp;#34; cloud_rank = 2 } gcp = { company = &amp;#34;Google&amp;#34; founder = &amp;#34;Larry Page and Sergey Brin&amp;#34; cloud_rank = 3 } } type = map(object({ company = string founder = string cloud_rank = number })) } The code snippet above defines a map for the top three cloud platforms with three attributes:</description></item><item><title>Templates</title><link>/docs/05/4-templates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/4-templates/</guid><description>Preparation Create a new directory for this exercise:
mkdir $LAB_ROOT/advanced/templates cd $LAB_ROOT/advanced/templates Step 5.4.1: Multiline strings Sometimes you&amp;rsquo;d like to construct multiline strings while avoiding \n escape sequences for readability.
Terraform offers so called &amp;ldquo;heredoc&amp;rdquo; style string literals to achieve that. The full documentation can be found at https://www.terraform.io/docs/language/expressions/strings.html Create a new file named variables.tf and add the following content:
variable &amp;#34;action&amp;#34; { default = &amp;#34;fun&amp;#34; } Create a new file named outputs.</description></item><item><title>Terraform CLI</title><link>/docs/05/5-terraform-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/5-terraform-operations/</guid><description>There are many more topics regarding Terraform. Here we will a have look over some of them:
state inspection state remove import debugging tflint Task 5.5.1: State Inspection As you have learned, the Terraform state represents the applied objects that have been successfully applied. Here is the example from our first applied config:
{ &amp;#34;version&amp;#34;: 4, &amp;#34;terraform_version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;serial&amp;#34;: 1, &amp;#34;lineage&amp;#34;: &amp;#34;e16466b0-a1f7-f0d0-ac77-263f52a3a511&amp;#34;, &amp;#34;outputs&amp;#34;: {}, &amp;#34;resources&amp;#34;: [ { &amp;#34;mode&amp;#34;: &amp;#34;managed&amp;#34;, &amp;#34;type&amp;#34;: &amp;#34;random_integer&amp;#34;, &amp;#34;name&amp;#34;: &amp;#34;acr&amp;#34;, &amp;#34;provider&amp;#34;: &amp;#34;provider[\&amp;#34;registry.</description></item><item><title>tfsec</title><link>/docs/05/6-tfsec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/6-tfsec/</guid><description>There tools to help detect common misconfigurations in terraform, on such tools is tfsec which has become part of the familiar trivy suite.
Task 5.6.1: Create a Terraform Configuration with a Misconfiguration As you have learned, the Terraform state represents the applied objects that have been successfully applied. Here is the example from our first applied config:
mkdir $LAB_ROOT/advanced/tfsec cd $LAB_ROOT/advanced/tfsec Create a file named main.tf with the following content:</description></item><item><title>Azure Keyvault</title><link>/docs/05/7-keyvault/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/05/7-keyvault/</guid><description>In a previous module in the CAS you created a (free Azure Account)[text ]. If you have still some free credit on it we can use that to create an Azure Key Vault. The pricing for it you find here :
Task 5.7.1: Create files to provision a Key Vault Create a new directory
mkdir $LAB_ROOT/advanced/keyvault cd $LAB_ROOT/advanced/keyvault Create a file named providers.tf and insert the following code:
terraform { required_version = &amp;#34;&amp;gt;=1.</description></item></channel></rss>